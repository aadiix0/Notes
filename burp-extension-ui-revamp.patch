diff --git a/.gradle/8.8/checksums/checksums.lock b/.gradle/8.8/checksums/checksums.lock
new file mode 100644
index 0000000..04d68bf
Binary files /dev/null and b/.gradle/8.8/checksums/checksums.lock differ
diff --git a/.gradle/8.8/checksums/md5-checksums.bin b/.gradle/8.8/checksums/md5-checksums.bin
new file mode 100644
index 0000000..609df1e
Binary files /dev/null and b/.gradle/8.8/checksums/md5-checksums.bin differ
diff --git a/.gradle/8.8/checksums/sha1-checksums.bin b/.gradle/8.8/checksums/sha1-checksums.bin
new file mode 100644
index 0000000..1b95de9
Binary files /dev/null and b/.gradle/8.8/checksums/sha1-checksums.bin differ
diff --git a/.gradle/8.8/dependencies-accessors/gc.properties b/.gradle/8.8/dependencies-accessors/gc.properties
new file mode 100644
index 0000000..e69de29
diff --git a/.gradle/8.8/executionHistory/executionHistory.bin b/.gradle/8.8/executionHistory/executionHistory.bin
new file mode 100644
index 0000000..714bc1d
Binary files /dev/null and b/.gradle/8.8/executionHistory/executionHistory.bin differ
diff --git a/.gradle/8.8/executionHistory/executionHistory.lock b/.gradle/8.8/executionHistory/executionHistory.lock
new file mode 100644
index 0000000..668b5d7
Binary files /dev/null and b/.gradle/8.8/executionHistory/executionHistory.lock differ
diff --git a/.gradle/8.8/fileChanges/last-build.bin b/.gradle/8.8/fileChanges/last-build.bin
new file mode 100644
index 0000000..f76dd23
Binary files /dev/null and b/.gradle/8.8/fileChanges/last-build.bin differ
diff --git a/.gradle/8.8/fileHashes/fileHashes.bin b/.gradle/8.8/fileHashes/fileHashes.bin
new file mode 100644
index 0000000..43b3cc4
Binary files /dev/null and b/.gradle/8.8/fileHashes/fileHashes.bin differ
diff --git a/.gradle/8.8/fileHashes/fileHashes.lock b/.gradle/8.8/fileHashes/fileHashes.lock
new file mode 100644
index 0000000..6c63807
Binary files /dev/null and b/.gradle/8.8/fileHashes/fileHashes.lock differ
diff --git a/.gradle/8.8/fileHashes/resourceHashesCache.bin b/.gradle/8.8/fileHashes/resourceHashesCache.bin
new file mode 100644
index 0000000..46b5473
Binary files /dev/null and b/.gradle/8.8/fileHashes/resourceHashesCache.bin differ
diff --git a/.gradle/8.8/gc.properties b/.gradle/8.8/gc.properties
new file mode 100644
index 0000000..e69de29
diff --git a/.gradle/buildOutputCleanup/buildOutputCleanup.lock b/.gradle/buildOutputCleanup/buildOutputCleanup.lock
new file mode 100644
index 0000000..e01bd62
Binary files /dev/null and b/.gradle/buildOutputCleanup/buildOutputCleanup.lock differ
diff --git a/.gradle/buildOutputCleanup/cache.properties b/.gradle/buildOutputCleanup/cache.properties
new file mode 100644
index 0000000..8938b7e
--- /dev/null
+++ b/.gradle/buildOutputCleanup/cache.properties
@@ -0,0 +1,2 @@
+#Tue Nov 11 08:39:12 UTC 2025
+gradle.version=8.8
diff --git a/.gradle/buildOutputCleanup/outputFiles.bin b/.gradle/buildOutputCleanup/outputFiles.bin
new file mode 100644
index 0000000..6b4373f
Binary files /dev/null and b/.gradle/buildOutputCleanup/outputFiles.bin differ
diff --git a/.gradle/vcs-1/gc.properties b/.gradle/vcs-1/gc.properties
new file mode 100644
index 0000000..e69de29
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000..01ccd17
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,22 @@
+plugins {
+    id 'java'
+    id 'com.github.johnrengelman.shadow' version '7.1.2'
+}
+
+group 'com.yourcompany'
+version '1.0'
+
+repositories {
+    mavenCentral()
+}
+
+dependencies {
+    implementation 'net.portswigger.burp.extensions:montoya-api:2025.10'
+    implementation 'com.formdev:flatlaf:3.4'
+}
+
+shadowJar {
+    archiveBaseName.set('BurpNotion')
+    archiveClassifier.set('')
+    archiveVersion.set('')
+}
diff --git a/build/classes/java/main/burp/BurpExtender$1.class b/build/classes/java/main/burp/BurpExtender$1.class
new file mode 100644
index 0000000..cb307af
Binary files /dev/null and b/build/classes/java/main/burp/BurpExtender$1.class differ
diff --git a/build/classes/java/main/burp/BurpExtender.class b/build/classes/java/main/burp/BurpExtender.class
new file mode 100644
index 0000000..df1000a
Binary files /dev/null and b/build/classes/java/main/burp/BurpExtender.class differ
diff --git a/build/classes/java/main/burp/ContextMenuProvider.class b/build/classes/java/main/burp/ContextMenuProvider.class
new file mode 100644
index 0000000..00d830c
Binary files /dev/null and b/build/classes/java/main/burp/ContextMenuProvider.class differ
diff --git a/build/classes/java/main/burp/MainPanel$1.class b/build/classes/java/main/burp/MainPanel$1.class
new file mode 100644
index 0000000..9798242
Binary files /dev/null and b/build/classes/java/main/burp/MainPanel$1.class differ
diff --git a/build/classes/java/main/burp/MainPanel$2.class b/build/classes/java/main/burp/MainPanel$2.class
new file mode 100644
index 0000000..8772944
Binary files /dev/null and b/build/classes/java/main/burp/MainPanel$2.class differ
diff --git a/build/classes/java/main/burp/MainPanel$TreeTransferHandler$NodesTransferable.class b/build/classes/java/main/burp/MainPanel$TreeTransferHandler$NodesTransferable.class
new file mode 100644
index 0000000..b258d34
Binary files /dev/null and b/build/classes/java/main/burp/MainPanel$TreeTransferHandler$NodesTransferable.class differ
diff --git a/build/classes/java/main/burp/MainPanel$TreeTransferHandler.class b/build/classes/java/main/burp/MainPanel$TreeTransferHandler.class
new file mode 100644
index 0000000..1bbca27
Binary files /dev/null and b/build/classes/java/main/burp/MainPanel$TreeTransferHandler.class differ
diff --git a/build/classes/java/main/burp/MainPanel.class b/build/classes/java/main/burp/MainPanel.class
new file mode 100644
index 0000000..20987fa
Binary files /dev/null and b/build/classes/java/main/burp/MainPanel.class differ
diff --git a/build/classes/java/main/burp/NoteEntry.class b/build/classes/java/main/burp/NoteEntry.class
new file mode 100644
index 0000000..f6146cf
Binary files /dev/null and b/build/classes/java/main/burp/NoteEntry.class differ
diff --git a/build/classes/java/main/burp/RichTextEditor$1.class b/build/classes/java/main/burp/RichTextEditor$1.class
new file mode 100644
index 0000000..c5bf304
Binary files /dev/null and b/build/classes/java/main/burp/RichTextEditor$1.class differ
diff --git a/build/classes/java/main/burp/RichTextEditor.class b/build/classes/java/main/burp/RichTextEditor.class
new file mode 100644
index 0000000..1070b56
Binary files /dev/null and b/build/classes/java/main/burp/RichTextEditor.class differ
diff --git a/build/libs/BurpNotion.jar b/build/libs/BurpNotion.jar
new file mode 100644
index 0000000..02b1033
Binary files /dev/null and b/build/libs/BurpNotion.jar differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/BurpExtender$1.class.uniqueId5 b/build/tmp/compileJava/compileTransaction/stash-dir/BurpExtender$1.class.uniqueId5
new file mode 100644
index 0000000..cb307af
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/BurpExtender$1.class.uniqueId5 differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/BurpExtender.class.uniqueId0 b/build/tmp/compileJava/compileTransaction/stash-dir/BurpExtender.class.uniqueId0
new file mode 100644
index 0000000..dcab7c4
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/BurpExtender.class.uniqueId0 differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/ContextMenuProvider.class.uniqueId6 b/build/tmp/compileJava/compileTransaction/stash-dir/ContextMenuProvider.class.uniqueId6
new file mode 100644
index 0000000..00d830c
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/ContextMenuProvider.class.uniqueId6 differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$1.class.uniqueId2 b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$1.class.uniqueId2
new file mode 100644
index 0000000..9798242
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$1.class.uniqueId2 differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$2.class.uniqueId7 b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$2.class.uniqueId7
new file mode 100644
index 0000000..e0ff199
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$2.class.uniqueId7 differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$TreeTransferHandler$NodesTransferable.class.uniqueId1 b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$TreeTransferHandler$NodesTransferable.class.uniqueId1
new file mode 100644
index 0000000..68de43d
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$TreeTransferHandler$NodesTransferable.class.uniqueId1 differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$TreeTransferHandler.class.uniqueId4 b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$TreeTransferHandler.class.uniqueId4
new file mode 100644
index 0000000..b1eff1b
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel$TreeTransferHandler.class.uniqueId4 differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel.class.uniqueId8 b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel.class.uniqueId8
new file mode 100644
index 0000000..5b06d2b
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/MainPanel.class.uniqueId8 differ
diff --git a/build/tmp/compileJava/compileTransaction/stash-dir/RichTextEditor.class.uniqueId3 b/build/tmp/compileJava/compileTransaction/stash-dir/RichTextEditor.class.uniqueId3
new file mode 100644
index 0000000..a87be60
Binary files /dev/null and b/build/tmp/compileJava/compileTransaction/stash-dir/RichTextEditor.class.uniqueId3 differ
diff --git a/build/tmp/compileJava/previous-compilation-data.bin b/build/tmp/compileJava/previous-compilation-data.bin
new file mode 100644
index 0000000..f36cd27
Binary files /dev/null and b/build/tmp/compileJava/previous-compilation-data.bin differ
diff --git a/build/tmp/shadowJar/MANIFEST.MF b/build/tmp/shadowJar/MANIFEST.MF
new file mode 100644
index 0000000..58630c0
--- /dev/null
+++ b/build/tmp/shadowJar/MANIFEST.MF
@@ -0,0 +1,2 @@
+Manifest-Version: 1.0
+
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000..e644113
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..a441313
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,7 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.8-bin.zip
+networkTimeout=10000
+validateDistributionUrl=true
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
new file mode 100755
index 0000000..b740cf1
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,249 @@
+#!/bin/sh
+
+#
+# Copyright © 2015-2021 the original authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+#
+#   Gradle start up script for POSIX generated by Gradle.
+#
+#   Important for running:
+#
+#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
+#       noncompliant, but you have some other compliant shell such as ksh or
+#       bash, then to run this script, type that shell name before the whole
+#       command line, like:
+#
+#           ksh Gradle
+#
+#       Busybox and similar reduced shells will NOT work, because this script
+#       requires all of these POSIX shell features:
+#         * functions;
+#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
+#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
+#         * compound commands having a testable exit status, especially «case»;
+#         * various built-in commands including «command», «set», and «ulimit».
+#
+#   Important for patching:
+#
+#   (2) This script targets any POSIX shell, so it avoids extensions provided
+#       by Bash, Ksh, etc; in particular arrays are avoided.
+#
+#       The "traditional" practice of packing multiple parameters into a
+#       space-separated string is a well documented source of bugs and security
+#       problems, so this is (mostly) avoided, by progressively accumulating
+#       options in "$@", and eventually passing that to Java.
+#
+#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
+#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
+#       see the in-line comments for details.
+#
+#       There are tweaks for specific operating systems such as AIX, CygWin,
+#       Darwin, MinGW, and NonStop.
+#
+#   (3) This script is generated from the Groovy template
+#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
+#       within the Gradle project.
+#
+#       You can find Gradle at https://github.com/gradle/gradle/.
+#
+##############################################################################
+
+# Attempt to set APP_HOME
+
+# Resolve links: $0 may be a link
+app_path=$0
+
+# Need this for daisy-chained symlinks.
+while
+    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
+    [ -h "$app_path" ]
+do
+    ls=$( ls -ld "$app_path" )
+    link=${ls#*' -> '}
+    case $link in             #(
+      /*)   app_path=$link ;; #(
+      *)    app_path=$APP_HOME$link ;;
+    esac
+done
+
+# This is normally unused
+# shellcheck disable=SC2034
+APP_BASE_NAME=${0##*/}
+# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
+APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD=maximum
+
+warn () {
+    echo "$*"
+} >&2
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+} >&2
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "$( uname )" in                #(
+  CYGWIN* )         cygwin=true  ;; #(
+  Darwin* )         darwin=true  ;; #(
+  MSYS* | MINGW* )  msys=true    ;; #(
+  NONSTOP* )        nonstop=true ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD=$JAVA_HOME/jre/sh/java
+    else
+        JAVACMD=$JAVA_HOME/bin/java
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD=java
+    if ! command -v java >/dev/null 2>&1
+    then
+        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+fi
+
+# Increase the maximum file descriptors if we can.
+if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
+    case $MAX_FD in #(
+      max*)
+        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        MAX_FD=$( ulimit -H -n ) ||
+            warn "Could not query maximum file descriptor limit"
+    esac
+    case $MAX_FD in  #(
+      '' | soft) :;; #(
+      *)
+        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
+        # shellcheck disable=SC2039,SC3045
+        ulimit -n "$MAX_FD" ||
+            warn "Could not set maximum file descriptor limit to $MAX_FD"
+    esac
+fi
+
+# Collect all arguments for the java command, stacking in reverse order:
+#   * args from the command line
+#   * the main class name
+#   * -classpath
+#   * -D...appname settings
+#   * --module-path (only if needed)
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if "$cygwin" || "$msys" ; then
+    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
+    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
+
+    JAVACMD=$( cygpath --unix "$JAVACMD" )
+
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    for arg do
+        if
+            case $arg in                                #(
+              -*)   false ;;                            # don't mess with options #(
+              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
+                    [ -e "$t" ] ;;                      #(
+              *)    false ;;
+            esac
+        then
+            arg=$( cygpath --path --ignore --mixed "$arg" )
+        fi
+        # Roll the args list around exactly as many times as the number of
+        # args, so each arg winds up back in the position where it started, but
+        # possibly modified.
+        #
+        # NB: a `for` loop captures its iteration list before it begins, so
+        # changing the positional parameters here affects neither the number of
+        # iterations, nor the values presented in `arg`.
+        shift                   # remove old arg
+        set -- "$@" "$arg"      # push replacement arg
+    done
+fi
+
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Collect all arguments for the java command:
+#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
+#     and any embedded shellness will be escaped.
+#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
+#     treated as '${Hostname}' itself on the command line.
+
+set -- \
+        "-Dorg.gradle.appname=$APP_BASE_NAME" \
+        -classpath "$CLASSPATH" \
+        org.gradle.wrapper.GradleWrapperMain \
+        "$@"
+
+# Stop when "xargs" is not available.
+if ! command -v xargs >/dev/null 2>&1
+then
+    die "xargs is not available"
+fi
+
+# Use "xargs" to parse quoted args.
+#
+# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
+#
+# In Bash we could simply go:
+#
+#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
+#   set -- "${ARGS[@]}" "$@"
+#
+# but POSIX shell has neither arrays nor command substitution, so instead we
+# post-process each arg (as a line of input to sed) to backslash-escape any
+# character that might be a shell metacharacter, then use eval to reverse
+# that process (while maintaining the separation between arguments), and wrap
+# the whole thing up as a single "set" statement.
+#
+# This will of course break if any of these variables contains a newline or
+# an unmatched quote.
+#
+
+eval "set -- $(
+        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
+        xargs -n1 |
+        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
+        tr '\n' ' '
+    )" '"$@"'
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 0000000..7101f8e
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,92 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%"=="" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%"=="" set DIRNAME=.
+@rem This is normally unused
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if %ERRORLEVEL% equ 0 goto execute
+
+echo. 1>&2
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo. 1>&2
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
+echo. 1>&2
+echo Please set the JAVA_HOME variable in your environment to match the 1>&2
+echo location of your Java installation. 1>&2
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if %ERRORLEVEL% equ 0 goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+set EXIT_CODE=%ERRORLEVEL%
+if %EXIT_CODE% equ 0 set EXIT_CODE=1
+if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
+exit /b %EXIT_CODE%
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/src/main/java/burp/BurpExtender.java b/src/main/java/burp/BurpExtender.java
new file mode 100644
index 0000000..f409e5b
--- /dev/null
+++ b/src/main/java/burp/BurpExtender.java
@@ -0,0 +1,65 @@
+package burp;
+
+import burp.api.montoya.BurpExtension;
+import burp.api.montoya.MontoyaApi;
+import burp.api.montoya.extension.ExtensionUnloadingHandler;
+import burp.api.montoya.logging.Logging;
+import burp.api.montoya.persistence.PersistedObject;
+import com.formdev.flatlaf.FlatDarculaLaf;
+
+import javax.swing.tree.DefaultTreeModel;
+import java.io.*;
+
+public class BurpExtender implements BurpExtension {
+    private MontoyaApi api;
+    private MainPanel mainPanel;
+
+    @Override
+    public void initialize(MontoyaApi api) {
+        this.api = api;
+        api.extension().setName("Burp Notion");
+
+        FlatDarculaLaf.setup();
+
+        Logging logging = api.logging();
+        logging.logToOutput("Burp Notion Extension loaded.");
+
+        mainPanel = new MainPanel();
+        loadNotes();
+        api.userInterface().registerSuiteTab("Burp Notion", mainPanel);
+        api.userInterface().registerContextMenuItemsProvider(new ContextMenuProvider(api, mainPanel));
+
+        api.extension().registerUnloadingHandler(new ExtensionUnloadingHandler() {
+            @Override
+            public void extensionUnloaded() {
+                saveNotes();
+            }
+        });
+    }
+
+    private void saveNotes() {
+        DefaultTreeModel treeModel = mainPanel.getOriginalTreeModel();
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(treeModel);
+            PersistedObject persistedObject = api.persistence().extensionData();
+            persistedObject.setByteArray("notes", burp.api.montoya.core.ByteArray.byteArray(bos.toByteArray()));
+        } catch (IOException e) {
+            api.logging().logToError(e);
+        }
+    }
+
+    private void loadNotes() {
+        PersistedObject persistedObject = api.persistence().extensionData();
+        burp.api.montoya.core.ByteArray notesBytes = persistedObject.getByteArray("notes");
+        if (notesBytes != null) {
+            try (ByteArrayInputStream bis = new ByteArrayInputStream(notesBytes.getBytes());
+                 ObjectInputStream in = new ObjectInputStream(bis)) {
+                DefaultTreeModel treeModel = (DefaultTreeModel) in.readObject();
+                mainPanel.setTreeModel(treeModel);
+            } catch (IOException | ClassNotFoundException e) {
+                api.logging().logToError(e);
+            }
+        }
+    }
+}
diff --git a/src/main/java/burp/ContextMenuProvider.java b/src/main/java/burp/ContextMenuProvider.java
new file mode 100644
index 0000000..0c3eb2d
--- /dev/null
+++ b/src/main/java/burp/ContextMenuProvider.java
@@ -0,0 +1,30 @@
+package burp;
+
+import burp.api.montoya.MontoyaApi;
+import burp.api.montoya.ui.contextmenu.ContextMenuEvent;
+import burp.api.montoya.ui.contextmenu.ContextMenuItemsProvider;
+import javax.swing.JMenuItem;
+import java.awt.Component;
+import java.util.List;
+
+public class ContextMenuProvider implements ContextMenuItemsProvider {
+    private final MainPanel mainPanel;
+
+    public ContextMenuProvider(MontoyaApi api, MainPanel mainPanel) {
+        this.mainPanel = mainPanel;
+    }
+
+    @Override
+    public List<Component> provideMenuItems(ContextMenuEvent event) {
+        JMenuItem menuItem = new JMenuItem("Link to Note");
+        menuItem.addActionListener(e -> {
+            mainPanel.linkRequest(event.messageEditorRequestResponse().get().requestResponse());
+        });
+
+        if (event.messageEditorRequestResponse().isEmpty()) {
+            return null;
+        }
+
+        return List.of(menuItem);
+    }
+}
diff --git a/src/main/java/burp/MainPanel.java b/src/main/java/burp/MainPanel.java
new file mode 100644
index 0000000..ba0edf1
--- /dev/null
+++ b/src/main/java/burp/MainPanel.java
@@ -0,0 +1,388 @@
+package burp;
+
+import javax.swing.*;
+import java.awt.*;
+import javax.swing.tree.*;
+import java.awt.datatransfer.DataFlavor;
+import java.awt.datatransfer.Transferable;
+import java.awt.datatransfer.UnsupportedFlavorException;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import burp.api.montoya.http.message.HttpRequestResponse;
+import javax.swing.event.DocumentEvent;
+import javax.swing.event.DocumentListener;
+
+public class MainPanel extends JPanel {
+    private JTree noteTree;
+    private DefaultTreeModel treeModel;
+    private DefaultTreeModel originalTreeModel;
+    private RichTextEditor editor;
+
+    public MainPanel() {
+        setLayout(new BorderLayout());
+
+        DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(new NoteEntry("Notes", "", true));
+        treeModel = new DefaultTreeModel(rootNode);
+        originalTreeModel = treeModel;
+
+        noteTree = new JTree(treeModel);
+        noteTree.setEditable(true);
+        noteTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
+        noteTree.setShowsRootHandles(true);
+        noteTree.setDragEnabled(true);
+        noteTree.setDropMode(DropMode.ON_OR_INSERT);
+        noteTree.setTransferHandler(new TreeTransferHandler());
+        JScrollPane treeScrollPane = new JScrollPane(noteTree);
+
+        JButton newNoteButton = new JButton("New Note");
+        newNoteButton.addActionListener(e -> {
+            DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) noteTree.getLastSelectedPathComponent();
+            DefaultMutableTreeNode parentNode;
+
+            if (selectedNode == null) {
+                parentNode = (DefaultMutableTreeNode) treeModel.getRoot();
+            } else {
+                NoteEntry selectedEntry = (NoteEntry) selectedNode.getUserObject();
+                if (selectedEntry.isFolder()) {
+                    parentNode = selectedNode;
+                } else {
+                    parentNode = (DefaultMutableTreeNode) selectedNode.getParent();
+                }
+            }
+            addNote(parentNode);
+        });
+
+        JButton newFolderButton = new JButton("New Folder");
+        newFolderButton.addActionListener(e -> {
+            DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) noteTree.getLastSelectedPathComponent();
+            DefaultMutableTreeNode parentNode;
+
+            if (selectedNode == null) {
+                parentNode = (DefaultMutableTreeNode) treeModel.getRoot();
+            } else {
+                NoteEntry selectedEntry = (NoteEntry) selectedNode.getUserObject();
+                if (selectedEntry.isFolder()) {
+                    parentNode = selectedNode;
+                } else {
+                    parentNode = (DefaultMutableTreeNode) selectedNode.getParent();
+                }
+            }
+            addFolder(parentNode);
+        });
+
+        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
+        buttonPanel.add(newNoteButton);
+        buttonPanel.add(newFolderButton);
+
+        JPanel treePanel = new JPanel(new BorderLayout());
+        treePanel.add(buttonPanel, BorderLayout.NORTH);
+        treePanel.add(treeScrollPane, BorderLayout.CENTER);
+
+        noteTree.addMouseListener(new MouseAdapter() {
+            public void mousePressed(MouseEvent e) {
+                if (e.isPopupTrigger()) {
+                    showContextMenu(e);
+                }
+            }
+
+            public void mouseReleased(MouseEvent e) {
+                if (e.isPopupTrigger()) {
+                    showContextMenu(e);
+                }
+            }
+        });
+
+        editor = new RichTextEditor();
+
+        noteTree.addTreeSelectionListener(e -> {
+            DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) noteTree.getLastSelectedPathComponent();
+            if (selectedNode != null) {
+                NoteEntry selectedEntry = (NoteEntry) selectedNode.getUserObject();
+                if (!selectedEntry.isFolder()) {
+                    editor.setText(selectedEntry.getContent());
+                    editor.setNoteEntry(selectedEntry); // Keep track of the current note
+                } else {
+                    editor.setNoteEntry(null); // Clear editor if a folder is selected
+                    editor.setText("");
+                }
+            }
+        });
+
+        JTextField searchField = new JTextField();
+        searchField.getDocument().addDocumentListener(new DocumentListener() {
+            public void changedUpdate(DocumentEvent e) {
+                filterTree(searchField.getText());
+            }
+            public void removeUpdate(DocumentEvent e) {
+                filterTree(searchField.getText());
+            }
+            public void insertUpdate(DocumentEvent e) {
+                filterTree(searchField.getText());
+            }
+        });
+
+        JTextField tagField = new JTextField();
+        tagField.addActionListener(e -> {
+            DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) noteTree.getLastSelectedPathComponent();
+            if (selectedNode != null) {
+                NoteEntry selectedEntry = (NoteEntry) selectedNode.getUserObject();
+                if (!selectedEntry.isFolder()) {
+                    selectedEntry.addTag(tagField.getText());
+                    tagField.setText("");
+                }
+            }
+        });
+
+        JPanel topPanel = new JPanel(new GridLayout(2, 1));
+        JPanel searchPanel = new JPanel(new BorderLayout());
+        searchPanel.add(new JLabel("Search: "), BorderLayout.WEST);
+        searchPanel.add(searchField, BorderLayout.CENTER);
+        JPanel tagPanel = new JPanel(new BorderLayout());
+        tagPanel.add(new JLabel("Tags: "), BorderLayout.WEST);
+        tagPanel.add(tagField, BorderLayout.CENTER);
+        topPanel.add(searchPanel);
+        topPanel.add(tagPanel);
+
+        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, treePanel, editor);
+        splitPane.setDividerLocation(200);
+
+        add(topPanel, BorderLayout.NORTH);
+        add(splitPane, BorderLayout.CENTER);
+    }
+
+    private void showContextMenu(MouseEvent e) {
+        TreePath path = noteTree.getPathForLocation(e.getX(), e.getY());
+        if (path == null) {
+            return;
+        }
+        noteTree.setSelectionPath(path);
+        DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) path.getLastPathComponent();
+        NoteEntry selectedEntry = (NoteEntry) selectedNode.getUserObject();
+
+        JPopupMenu contextMenu = new JPopupMenu();
+
+        if (selectedEntry.isFolder()) {
+            JMenuItem addNoteItem = new JMenuItem("Add Note");
+            addNoteItem.addActionListener(ae -> addNote(selectedNode));
+            contextMenu.add(addNoteItem);
+
+            JMenuItem addFolderItem = new JMenuItem("Add Folder");
+            addFolderItem.addActionListener(ae -> addFolder(selectedNode));
+            contextMenu.add(addFolderItem);
+        }
+
+        JMenuItem renameItem = new JMenuItem("Rename");
+        renameItem.addActionListener(ae -> noteTree.startEditingAtPath(path));
+        contextMenu.add(renameItem);
+
+        JMenuItem deleteItem = new JMenuItem("Delete");
+        deleteItem.addActionListener(ae -> deleteNode(selectedNode));
+        contextMenu.add(deleteItem);
+
+        contextMenu.show(noteTree, e.getX(), e.getY());
+    }
+
+    private void addNote(DefaultMutableTreeNode parent) {
+        String noteName = JOptionPane.showInputDialog(this, "Enter note name:", "New Note", JOptionPane.PLAIN_MESSAGE);
+        if (noteName != null && !noteName.trim().isEmpty()) {
+            DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(new NoteEntry(noteName, "", false));
+            treeModel.insertNodeInto(newNode, parent, parent.getChildCount());
+            noteTree.scrollPathToVisible(new TreePath(newNode.getPath()));
+        }
+    }
+
+    private void addFolder(DefaultMutableTreeNode parent) {
+        String folderName = JOptionPane.showInputDialog(this, "Enter folder name:", "New Folder", JOptionPane.PLAIN_MESSAGE);
+        if (folderName != null && !folderName.trim().isEmpty()) {
+            DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(new NoteEntry(folderName, "", true));
+            treeModel.insertNodeInto(newNode, parent, parent.getChildCount());
+            noteTree.scrollPathToVisible(new TreePath(newNode.getPath()));
+        }
+    }
+
+    private void deleteNode(DefaultMutableTreeNode node) {
+        if (node.getParent() != null) {
+            treeModel.removeNodeFromParent(node);
+        }
+    }
+
+    public DefaultTreeModel getTreeModel() {
+        return treeModel;
+    }
+
+    public void setTreeModel(DefaultTreeModel treeModel) {
+        this.treeModel = treeModel;
+        noteTree.setModel(treeModel);
+    }
+
+    public DefaultTreeModel getOriginalTreeModel() {
+        return originalTreeModel;
+    }
+
+    public void linkRequest(HttpRequestResponse requestResponse) {
+        DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) noteTree.getLastSelectedPathComponent();
+        if (selectedNode != null) {
+            NoteEntry selectedEntry = (NoteEntry) selectedNode.getUserObject();
+            if (!selectedEntry.isFolder()) {
+                String link = String.format("<a href=\"%s\">%s</a>", requestResponse.request().url(), requestResponse.request().url());
+                selectedEntry.setContent(selectedEntry.getContent() + "\n" + link);
+                editor.setText(selectedEntry.getContent());
+            }
+        }
+    }
+
+    private void filterTree(String searchText) {
+        if (searchText.isEmpty()) {
+            noteTree.setModel(originalTreeModel);
+            treeModel = originalTreeModel;
+            return;
+        }
+        DefaultMutableTreeNode root = (DefaultMutableTreeNode) originalTreeModel.getRoot();
+        DefaultMutableTreeNode filteredRoot = new DefaultMutableTreeNode(root.getUserObject());
+        filter(root, filteredRoot, searchText.toLowerCase());
+        treeModel = new DefaultTreeModel(filteredRoot);
+        noteTree.setModel(treeModel);
+    }
+
+    private void filter(DefaultMutableTreeNode parent, DefaultMutableTreeNode filteredParent, String searchText) {
+        for (int i = 0; i < parent.getChildCount(); i++) {
+            DefaultMutableTreeNode child = (DefaultMutableTreeNode) parent.getChildAt(i);
+            NoteEntry entry = (NoteEntry) child.getUserObject();
+            if (entry.getTitle().toLowerCase().contains(searchText) ||
+                entry.getContent().toLowerCase().contains(searchText) ||
+                entry.getTags().stream().anyMatch(tag -> tag.toLowerCase().contains(searchText))) {
+                DefaultMutableTreeNode filteredChild = new DefaultMutableTreeNode(entry);
+                filteredParent.add(filteredChild);
+                filter(child, filteredChild, searchText);
+            }
+        }
+    }
+
+    class TreeTransferHandler extends TransferHandler {
+        DataFlavor nodesFlavor;
+        DataFlavor[] flavors = new DataFlavor[1];
+        DefaultMutableTreeNode[] nodesToRemove;
+
+        public TreeTransferHandler() {
+            try {
+                String mimeType = DataFlavor.javaJVMLocalObjectMimeType +
+                                  ";class=\"" +
+                                  javax.swing.tree.DefaultMutableTreeNode[].class.getName() +
+                                  "\"";
+                nodesFlavor = new DataFlavor(mimeType);
+                flavors[0] = nodesFlavor;
+            } catch (ClassNotFoundException e) {
+                System.out.println("ClassNotFound: " + e.getMessage());
+            }
+        }
+
+        public boolean canImport(TransferSupport support) {
+            if (!support.isDrop()) {
+                return false;
+            }
+            support.setShowDropLocation(true);
+            if (!support.isDataFlavorSupported(nodesFlavor)) {
+                return false;
+            }
+            JTree.DropLocation dl = (JTree.DropLocation) support.getDropLocation();
+            JTree tree = (JTree) support.getComponent();
+            int dropRow = tree.getRowForPath(dl.getPath());
+            int[] selRows = tree.getSelectionRows();
+            for (int i = 0; i < selRows.length; i++) {
+                if (selRows[i] == dropRow) {
+                    return false;
+                }
+            }
+            TreePath dest = dl.getPath();
+            DefaultMutableTreeNode target = (DefaultMutableTreeNode) dest.getLastPathComponent();
+            NoteEntry targetEntry = (NoteEntry) target.getUserObject();
+            if (!targetEntry.isFolder()) {
+                return false;
+            }
+            return true;
+        }
+
+        protected Transferable createTransferable(JComponent c) {
+            JTree tree = (JTree) c;
+            TreePath[] paths = tree.getSelectionPaths();
+            if (paths != null) {
+                DefaultMutableTreeNode[] nodes = new DefaultMutableTreeNode[paths.length];
+                for (int i = 0; i < paths.length; i++) {
+                    nodes[i] = (DefaultMutableTreeNode) paths[i].getLastPathComponent();
+                }
+                return new NodesTransferable(nodes);
+            }
+            return null;
+        }
+
+        public int getSourceActions(JComponent c) {
+            return MOVE;
+        }
+
+        public boolean importData(TransferSupport support) {
+            if (!canImport(support)) {
+                return false;
+            }
+            DefaultMutableTreeNode[] nodes = null;
+            try {
+                Transferable t = support.getTransferable();
+                nodes = (DefaultMutableTreeNode[]) t.getTransferData(nodesFlavor);
+            } catch (UnsupportedFlavorException ufe) {
+                System.out.println("UnsupportedFlavor: " + ufe.getMessage());
+            } catch (java.io.IOException ioe) {
+                System.out.println("I/O error: " + ioe.getMessage());
+            }
+            JTree.DropLocation dl = (JTree.DropLocation) support.getDropLocation();
+            int childIndex = dl.getChildIndex();
+            TreePath dest = dl.getPath();
+            DefaultMutableTreeNode parent = (DefaultMutableTreeNode) dest.getLastPathComponent();
+            JTree tree = (JTree) support.getComponent();
+            DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
+            int index = childIndex;
+            if (childIndex == -1) {
+                index = parent.getChildCount();
+            }
+            nodesToRemove = new DefaultMutableTreeNode[nodes.length];
+            for (int i = 0; i < nodes.length; i++) {
+                nodesToRemove[i] = nodes[i];
+            }
+            for (int i = 0; i < nodes.length; i++) {
+                model.insertNodeInto(nodes[i], parent, index++);
+            }
+            return true;
+        }
+
+        protected void exportDone(JComponent source, Transferable data, int action) {
+            if ((action & MOVE) == MOVE) {
+                JTree tree = (JTree) source;
+                DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
+                for (int i = 0; i < nodesToRemove.length; i++) {
+                    model.removeNodeFromParent(nodesToRemove[i]);
+                }
+            }
+        }
+
+        public class NodesTransferable implements Transferable {
+            DefaultMutableTreeNode[] nodes;
+
+            public NodesTransferable(DefaultMutableTreeNode[] nodes) {
+                this.nodes = nodes;
+            }
+
+            public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {
+                if (!isDataFlavorSupported(flavor)) {
+                    throw new UnsupportedFlavorException(flavor);
+                }
+                return nodes;
+            }
+
+            public DataFlavor[] getTransferDataFlavors() {
+                return flavors;
+            }
+
+            public boolean isDataFlavorSupported(DataFlavor flavor) {
+                return nodesFlavor.equals(flavor);
+            }
+        }
+    }
+}
diff --git a/src/main/java/burp/NoteEntry.java b/src/main/java/burp/NoteEntry.java
new file mode 100644
index 0000000..75981b1
--- /dev/null
+++ b/src/main/java/burp/NoteEntry.java
@@ -0,0 +1,53 @@
+package burp;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+public class NoteEntry implements Serializable {
+    private static final long serialVersionUID = 1L;
+    private String title;
+    private String content;
+    private boolean isFolder;
+    private List<String> tags;
+
+    public NoteEntry(String title, String content, boolean isFolder) {
+        this.title = title;
+        this.content = content;
+        this.isFolder = isFolder;
+        this.tags = new ArrayList<>();
+    }
+
+    public String getTitle() {
+        return title;
+    }
+
+    public void setTitle(String title) {
+        this.title = title;
+    }
+
+    public String getContent() {
+        return content;
+    }
+
+    public void setContent(String content) {
+        this.content = content;
+    }
+
+    public boolean isFolder() {
+        return isFolder;
+    }
+
+    public void addTag(String tag) {
+        tags.add(tag);
+    }
+
+    public List<String> getTags() {
+        return tags;
+    }
+
+    @Override
+    public String toString() {
+        return title;
+    }
+}
diff --git a/src/main/java/burp/RichTextEditor.java b/src/main/java/burp/RichTextEditor.java
new file mode 100644
index 0000000..b950d6e
--- /dev/null
+++ b/src/main/java/burp/RichTextEditor.java
@@ -0,0 +1,155 @@
+package burp;
+
+import javax.swing.*;
+import java.awt.*;
+import javax.swing.text.AttributeSet;
+import javax.swing.text.BadLocationException;
+import javax.swing.text.Element;
+import javax.swing.text.MutableAttributeSet;
+import javax.swing.text.SimpleAttributeSet;
+import javax.swing.text.StyleConstants;
+import javax.swing.text.StyledDocument;
+import javax.swing.text.StyledEditorKit;
+import javax.swing.text.html.HTMLEditorKit;
+import javax.swing.event.HyperlinkEvent;
+import java.io.IOException;
+import java.net.URISyntaxException;
+
+import javax.swing.event.DocumentEvent;
+import javax.swing.event.DocumentListener;
+
+public class RichTextEditor extends JPanel {
+    private JTextPane textPane;
+    private NoteEntry currentNoteEntry;
+
+    public RichTextEditor() {
+        setLayout(new BorderLayout());
+
+        textPane = new JTextPane();
+        textPane.setEditorKit(new HTMLEditorKit());
+        textPane.addHyperlinkListener(e -> {
+            if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
+                if (Desktop.isDesktopSupported()) {
+                    try {
+                        Desktop.getDesktop().browse(e.getURL().toURI());
+                    } catch (IOException | URISyntaxException ex) {
+                        ex.printStackTrace();
+                    }
+                }
+            }
+        });
+        JScrollPane scrollPane = new JScrollPane(textPane);
+
+        textPane.getDocument().addDocumentListener(new DocumentListener() {
+            @Override
+            public void insertUpdate(DocumentEvent e) {
+                saveContent();
+            }
+
+            @Override
+            public void removeUpdate(DocumentEvent e) {
+                saveContent();
+            }
+
+            @Override
+            public void changedUpdate(DocumentEvent e) {
+                saveContent();
+            }
+        });
+
+        JToolBar toolBar = new JToolBar();
+        addFormattingButtons(toolBar);
+
+        add(toolBar, BorderLayout.NORTH);
+        add(scrollPane, BorderLayout.CENTER);
+    }
+
+    private void addFormattingButtons(JToolBar toolBar) {
+        JButton boldButton = new JButton(new StyledEditorKit.BoldAction());
+        boldButton.setText("Bold");
+        toolBar.add(boldButton);
+
+        JButton italicButton = new JButton(new StyledEditorKit.ItalicAction());
+        italicButton.setText("Italic");
+        toolBar.add(italicButton);
+
+        JButton bulletButton = new JButton("Bullet");
+        bulletButton.addActionListener(e -> toggleBulletPoints());
+        toolBar.add(bulletButton);
+
+        JButton checklistButton = new JButton("Checklist");
+        checklistButton.addActionListener(e -> insertChecklist());
+        toolBar.add(checklistButton);
+
+        JButton quoteButton = new JButton("Quote");
+        quoteButton.addActionListener(e -> setBlockStyle(true, false));
+        toolBar.add(quoteButton);
+
+        JButton codeButton = new JButton("Code");
+        codeButton.addActionListener(e -> setBlockStyle(false, true));
+        toolBar.add(codeButton);
+    }
+
+    private void toggleBulletPoints() {
+        try {
+            StyledDocument doc = textPane.getStyledDocument();
+            int start = textPane.getSelectionStart();
+            int end = textPane.getSelectionEnd();
+            Element startPara = doc.getParagraphElement(start);
+            Element endPara = doc.getParagraphElement(end);
+            for (int i = startPara.getStartOffset(); i <= endPara.getEndOffset(); i = doc.getParagraphElement(i).getEndOffset() + 1) {
+                Element para = doc.getParagraphElement(i);
+                if (para.getEndOffset() > doc.getLength()) {
+                    break;
+                }
+                String text = doc.getText(para.getStartOffset(), para.getEndOffset() - para.getStartOffset());
+                if (text.startsWith("• ")) {
+                    doc.remove(para.getStartOffset(), 2);
+                } else {
+                    doc.insertString(para.getStartOffset(), "• ", null);
+                }
+            }
+        } catch (BadLocationException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void insertChecklist() {
+        try {
+            textPane.getDocument().insertString(textPane.getCaretPosition(), "[ ] ", null);
+        } catch (BadLocationException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void setBlockStyle(boolean isQuote, boolean isCode) {
+        MutableAttributeSet attrs = new SimpleAttributeSet();
+        StyleConstants.setFontFamily(attrs, isCode ? "Monospaced" : "SansSerif");
+        StyleConstants.setForeground(attrs, isCode ? Color.DARK_GRAY : Color.BLACK);
+        StyleConstants.setBackground(attrs, isQuote ? new Color(240, 240, 240) : Color.WHITE);
+        StyleConstants.setLeftIndent(attrs, isQuote ? 20 : 0);
+        StyleConstants.setRightIndent(attrs, isQuote ? 20 : 0);
+        StyledDocument doc = textPane.getStyledDocument();
+        int start = textPane.getSelectionStart();
+        int end = textPane.getSelectionEnd();
+        doc.setCharacterAttributes(start, end - start, attrs, false);
+    }
+
+    public String getText() {
+        return textPane.getText();
+    }
+
+    public void setText(String text) {
+        textPane.setText(text);
+    }
+
+    public void setNoteEntry(NoteEntry noteEntry) {
+        this.currentNoteEntry = noteEntry;
+    }
+
+    private void saveContent() {
+        if (currentNoteEntry != null) {
+            currentNoteEntry.setContent(textPane.getText());
+        }
+    }
+}
